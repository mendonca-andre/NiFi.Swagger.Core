/* 
 * NiFi Rest Api
 *
 * The Rest Api provides programmatic access to command and control a NiFi instance in real time. Start and                                              stop processors, monitor queues, query provenance data, and more. Each endpoint below includes a description,                                             definitions of the expected input and output, potential response codes, and the authorizations required                                             to invoke each service.
 *
 * OpenAPI spec version: 1.9.1
 * Contact: dev@nifi.apache.org
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

namespace NiFi.Swagger.Core.Api
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Linq;

    using NiFi.Swagger.Core.Client;
    using NiFi.Swagger.Core.Model;

    using RestSharp;

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPoliciesApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Creates an access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>AccessPolicyEntity</returns>
        AccessPolicyEntity CreateAccessPolicy (AccessPolicyEntity body);

        /// <summary>
        /// Creates an access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>ApiResponse of AccessPolicyEntity</returns>
        ApiResponse<AccessPolicyEntity> CreateAccessPolicyWithHttpInfo (AccessPolicyEntity body);
        /// <summary>
        /// Gets an access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <returns>AccessPolicyEntity</returns>
        AccessPolicyEntity GetAccessPolicy (string id);

        /// <summary>
        /// Gets an access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <returns>ApiResponse of AccessPolicyEntity</returns>
        ApiResponse<AccessPolicyEntity> GetAccessPolicyWithHttpInfo (string id);
        /// <summary>
        /// Gets an access policy for the specified action and resource
        /// </summary>
        /// <remarks>
        /// Will return the effective policy if no component specific policy exists for the specified action and resource. Must have Read permissions to the policy with the desired action and resource. Permissions for the policy that is returned will be indicated in the response. This means the client could be authorized to get the policy for a given component but the effective policy may be inherited from an ancestor Process Group. If the client does not have permissions to that policy, the response will not include the policy and the permissions in the response will be marked accordingly. If the client does not have permissions to the policy of the desired action and resource a 403 response will be returned.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="action">The request action.</param>
        /// <param name="resource">The resource of the policy.</param>
        /// <returns>AccessPolicyEntity</returns>
        AccessPolicyEntity GetAccessPolicyForResource (string action, string resource);

        /// <summary>
        /// Gets an access policy for the specified action and resource
        /// </summary>
        /// <remarks>
        /// Will return the effective policy if no component specific policy exists for the specified action and resource. Must have Read permissions to the policy with the desired action and resource. Permissions for the policy that is returned will be indicated in the response. This means the client could be authorized to get the policy for a given component but the effective policy may be inherited from an ancestor Process Group. If the client does not have permissions to that policy, the response will not include the policy and the permissions in the response will be marked accordingly. If the client does not have permissions to the policy of the desired action and resource a 403 response will be returned.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="action">The request action.</param>
        /// <param name="resource">The resource of the policy.</param>
        /// <returns>ApiResponse of AccessPolicyEntity</returns>
        ApiResponse<AccessPolicyEntity> GetAccessPolicyForResourceWithHttpInfo (string action, string resource);
        /// <summary>
        /// Deletes an access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="version">The revision is used to verify the client is working with the latest version of the flow. (optional)</param>
        /// <param name="clientId">If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response. (optional)</param>
        /// <param name="disconnectedNodeAcknowledged">Acknowledges that this node is disconnected to allow for mutable requests to proceed. (optional, default to false)</param>
        /// <returns>AccessPolicyEntity</returns>
        AccessPolicyEntity RemoveAccessPolicy (string id, string version = null, string clientId = null, bool? disconnectedNodeAcknowledged = null);

        /// <summary>
        /// Deletes an access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="version">The revision is used to verify the client is working with the latest version of the flow. (optional)</param>
        /// <param name="clientId">If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response. (optional)</param>
        /// <param name="disconnectedNodeAcknowledged">Acknowledges that this node is disconnected to allow for mutable requests to proceed. (optional, default to false)</param>
        /// <returns>ApiResponse of AccessPolicyEntity</returns>
        ApiResponse<AccessPolicyEntity> RemoveAccessPolicyWithHttpInfo (string id, string version = null, string clientId = null, bool? disconnectedNodeAcknowledged = null);
        /// <summary>
        /// Updates a access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>AccessPolicyEntity</returns>
        AccessPolicyEntity UpdateAccessPolicy (string id, AccessPolicyEntity body);

        /// <summary>
        /// Updates a access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>ApiResponse of AccessPolicyEntity</returns>
        ApiResponse<AccessPolicyEntity> UpdateAccessPolicyWithHttpInfo (string id, AccessPolicyEntity body);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Creates an access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>Task of AccessPolicyEntity</returns>
        System.Threading.Tasks.Task<AccessPolicyEntity> CreateAccessPolicyAsync (AccessPolicyEntity body);

        /// <summary>
        /// Creates an access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>Task of ApiResponse (AccessPolicyEntity)</returns>
        System.Threading.Tasks.Task<ApiResponse<AccessPolicyEntity>> CreateAccessPolicyAsyncWithHttpInfo (AccessPolicyEntity body);
        /// <summary>
        /// Gets an access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <returns>Task of AccessPolicyEntity</returns>
        System.Threading.Tasks.Task<AccessPolicyEntity> GetAccessPolicyAsync (string id);

        /// <summary>
        /// Gets an access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <returns>Task of ApiResponse (AccessPolicyEntity)</returns>
        System.Threading.Tasks.Task<ApiResponse<AccessPolicyEntity>> GetAccessPolicyAsyncWithHttpInfo (string id);
        /// <summary>
        /// Gets an access policy for the specified action and resource
        /// </summary>
        /// <remarks>
        /// Will return the effective policy if no component specific policy exists for the specified action and resource. Must have Read permissions to the policy with the desired action and resource. Permissions for the policy that is returned will be indicated in the response. This means the client could be authorized to get the policy for a given component but the effective policy may be inherited from an ancestor Process Group. If the client does not have permissions to that policy, the response will not include the policy and the permissions in the response will be marked accordingly. If the client does not have permissions to the policy of the desired action and resource a 403 response will be returned.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="action">The request action.</param>
        /// <param name="resource">The resource of the policy.</param>
        /// <returns>Task of AccessPolicyEntity</returns>
        System.Threading.Tasks.Task<AccessPolicyEntity> GetAccessPolicyForResourceAsync (string action, string resource);

        /// <summary>
        /// Gets an access policy for the specified action and resource
        /// </summary>
        /// <remarks>
        /// Will return the effective policy if no component specific policy exists for the specified action and resource. Must have Read permissions to the policy with the desired action and resource. Permissions for the policy that is returned will be indicated in the response. This means the client could be authorized to get the policy for a given component but the effective policy may be inherited from an ancestor Process Group. If the client does not have permissions to that policy, the response will not include the policy and the permissions in the response will be marked accordingly. If the client does not have permissions to the policy of the desired action and resource a 403 response will be returned.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="action">The request action.</param>
        /// <param name="resource">The resource of the policy.</param>
        /// <returns>Task of ApiResponse (AccessPolicyEntity)</returns>
        System.Threading.Tasks.Task<ApiResponse<AccessPolicyEntity>> GetAccessPolicyForResourceAsyncWithHttpInfo (string action, string resource);
        /// <summary>
        /// Deletes an access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="version">The revision is used to verify the client is working with the latest version of the flow. (optional)</param>
        /// <param name="clientId">If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response. (optional)</param>
        /// <param name="disconnectedNodeAcknowledged">Acknowledges that this node is disconnected to allow for mutable requests to proceed. (optional, default to false)</param>
        /// <returns>Task of AccessPolicyEntity</returns>
        System.Threading.Tasks.Task<AccessPolicyEntity> RemoveAccessPolicyAsync (string id, string version = null, string clientId = null, bool? disconnectedNodeAcknowledged = null);

        /// <summary>
        /// Deletes an access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="version">The revision is used to verify the client is working with the latest version of the flow. (optional)</param>
        /// <param name="clientId">If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response. (optional)</param>
        /// <param name="disconnectedNodeAcknowledged">Acknowledges that this node is disconnected to allow for mutable requests to proceed. (optional, default to false)</param>
        /// <returns>Task of ApiResponse (AccessPolicyEntity)</returns>
        System.Threading.Tasks.Task<ApiResponse<AccessPolicyEntity>> RemoveAccessPolicyAsyncWithHttpInfo (string id, string version = null, string clientId = null, bool? disconnectedNodeAcknowledged = null);
        /// <summary>
        /// Updates a access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>Task of AccessPolicyEntity</returns>
        System.Threading.Tasks.Task<AccessPolicyEntity> UpdateAccessPolicyAsync (string id, AccessPolicyEntity body);

        /// <summary>
        /// Updates a access policy
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>Task of ApiResponse (AccessPolicyEntity)</returns>
        System.Threading.Tasks.Task<ApiResponse<AccessPolicyEntity>> UpdateAccessPolicyAsyncWithHttpInfo (string id, AccessPolicyEntity body);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class PoliciesApi : IPoliciesApi
    {
        private ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="PoliciesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public PoliciesApi(String basePath)
        {
            this.Configuration = new Configuration { BasePath = basePath };

            this.ExceptionFactory = Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PoliciesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public PoliciesApi(Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Configuration.Default;
            else
                this.Configuration = configuration;

            this.ExceptionFactory = Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (this._exceptionFactory != null && this._exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return this._exceptionFactory;
            }
            set { this._exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Creates an access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>AccessPolicyEntity</returns>
        public AccessPolicyEntity CreateAccessPolicy (AccessPolicyEntity body)
        {
             ApiResponse<AccessPolicyEntity> localVarResponse = this.CreateAccessPolicyWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Creates an access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>ApiResponse of AccessPolicyEntity</returns>
        public ApiResponse< AccessPolicyEntity > CreateAccessPolicyWithHttpInfo (AccessPolicyEntity body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling PoliciesApi->CreateAccessPolicy");

            var localVarPath = "/policies";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CreateAccessPolicy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AccessPolicyEntity>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AccessPolicyEntity) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AccessPolicyEntity)));
        }

        /// <summary>
        /// Creates an access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>Task of AccessPolicyEntity</returns>
        public async System.Threading.Tasks.Task<AccessPolicyEntity> CreateAccessPolicyAsync (AccessPolicyEntity body)
        {
             ApiResponse<AccessPolicyEntity> localVarResponse = await this.CreateAccessPolicyAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Creates an access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>Task of ApiResponse (AccessPolicyEntity)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AccessPolicyEntity>> CreateAccessPolicyAsyncWithHttpInfo (AccessPolicyEntity body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling PoliciesApi->CreateAccessPolicy");

            var localVarPath = "/policies";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("CreateAccessPolicy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AccessPolicyEntity>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AccessPolicyEntity) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AccessPolicyEntity)));
        }

        /// <summary>
        /// Gets an access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <returns>AccessPolicyEntity</returns>
        public AccessPolicyEntity GetAccessPolicy (string id)
        {
             ApiResponse<AccessPolicyEntity> localVarResponse = this.GetAccessPolicyWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets an access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <returns>ApiResponse of AccessPolicyEntity</returns>
        public ApiResponse< AccessPolicyEntity > GetAccessPolicyWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling PoliciesApi->GetAccessPolicy");

            var localVarPath = "/policies/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAccessPolicy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AccessPolicyEntity>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AccessPolicyEntity) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AccessPolicyEntity)));
        }

        /// <summary>
        /// Gets an access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <returns>Task of AccessPolicyEntity</returns>
        public async System.Threading.Tasks.Task<AccessPolicyEntity> GetAccessPolicyAsync (string id)
        {
             ApiResponse<AccessPolicyEntity> localVarResponse = await this.GetAccessPolicyAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets an access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <returns>Task of ApiResponse (AccessPolicyEntity)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AccessPolicyEntity>> GetAccessPolicyAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling PoliciesApi->GetAccessPolicy");

            var localVarPath = "/policies/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAccessPolicy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AccessPolicyEntity>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AccessPolicyEntity) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AccessPolicyEntity)));
        }

        /// <summary>
        /// Gets an access policy for the specified action and resource Will return the effective policy if no component specific policy exists for the specified action and resource. Must have Read permissions to the policy with the desired action and resource. Permissions for the policy that is returned will be indicated in the response. This means the client could be authorized to get the policy for a given component but the effective policy may be inherited from an ancestor Process Group. If the client does not have permissions to that policy, the response will not include the policy and the permissions in the response will be marked accordingly. If the client does not have permissions to the policy of the desired action and resource a 403 response will be returned.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="action">The request action.</param>
        /// <param name="resource">The resource of the policy.</param>
        /// <returns>AccessPolicyEntity</returns>
        public AccessPolicyEntity GetAccessPolicyForResource (string action, string resource)
        {
             ApiResponse<AccessPolicyEntity> localVarResponse = this.GetAccessPolicyForResourceWithHttpInfo(action, resource);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets an access policy for the specified action and resource Will return the effective policy if no component specific policy exists for the specified action and resource. Must have Read permissions to the policy with the desired action and resource. Permissions for the policy that is returned will be indicated in the response. This means the client could be authorized to get the policy for a given component but the effective policy may be inherited from an ancestor Process Group. If the client does not have permissions to that policy, the response will not include the policy and the permissions in the response will be marked accordingly. If the client does not have permissions to the policy of the desired action and resource a 403 response will be returned.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="action">The request action.</param>
        /// <param name="resource">The resource of the policy.</param>
        /// <returns>ApiResponse of AccessPolicyEntity</returns>
        public ApiResponse< AccessPolicyEntity > GetAccessPolicyForResourceWithHttpInfo (string action, string resource)
        {
            // verify the required parameter 'action' is set
            if (action == null)
                throw new ApiException(400, "Missing required parameter 'action' when calling PoliciesApi->GetAccessPolicyForResource");
            // verify the required parameter 'resource' is set
            if (resource == null)
                throw new ApiException(400, "Missing required parameter 'resource' when calling PoliciesApi->GetAccessPolicyForResource");

            var localVarPath = "/policies/{action}/{resource}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (action != null) localVarPathParams.Add("action", this.Configuration.ApiClient.ParameterToString(action)); // path parameter
            if (resource != null) localVarPathParams.Add("resource", this.Configuration.ApiClient.ParameterToString(resource)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAccessPolicyForResource", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AccessPolicyEntity>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AccessPolicyEntity) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AccessPolicyEntity)));
        }

        /// <summary>
        /// Gets an access policy for the specified action and resource Will return the effective policy if no component specific policy exists for the specified action and resource. Must have Read permissions to the policy with the desired action and resource. Permissions for the policy that is returned will be indicated in the response. This means the client could be authorized to get the policy for a given component but the effective policy may be inherited from an ancestor Process Group. If the client does not have permissions to that policy, the response will not include the policy and the permissions in the response will be marked accordingly. If the client does not have permissions to the policy of the desired action and resource a 403 response will be returned.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="action">The request action.</param>
        /// <param name="resource">The resource of the policy.</param>
        /// <returns>Task of AccessPolicyEntity</returns>
        public async System.Threading.Tasks.Task<AccessPolicyEntity> GetAccessPolicyForResourceAsync (string action, string resource)
        {
             ApiResponse<AccessPolicyEntity> localVarResponse = await this.GetAccessPolicyForResourceAsyncWithHttpInfo(action, resource);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets an access policy for the specified action and resource Will return the effective policy if no component specific policy exists for the specified action and resource. Must have Read permissions to the policy with the desired action and resource. Permissions for the policy that is returned will be indicated in the response. This means the client could be authorized to get the policy for a given component but the effective policy may be inherited from an ancestor Process Group. If the client does not have permissions to that policy, the response will not include the policy and the permissions in the response will be marked accordingly. If the client does not have permissions to the policy of the desired action and resource a 403 response will be returned.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="action">The request action.</param>
        /// <param name="resource">The resource of the policy.</param>
        /// <returns>Task of ApiResponse (AccessPolicyEntity)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AccessPolicyEntity>> GetAccessPolicyForResourceAsyncWithHttpInfo (string action, string resource)
        {
            // verify the required parameter 'action' is set
            if (action == null)
                throw new ApiException(400, "Missing required parameter 'action' when calling PoliciesApi->GetAccessPolicyForResource");
            // verify the required parameter 'resource' is set
            if (resource == null)
                throw new ApiException(400, "Missing required parameter 'resource' when calling PoliciesApi->GetAccessPolicyForResource");

            var localVarPath = "/policies/{action}/{resource}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (action != null) localVarPathParams.Add("action", this.Configuration.ApiClient.ParameterToString(action)); // path parameter
            if (resource != null) localVarPathParams.Add("resource", this.Configuration.ApiClient.ParameterToString(resource)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAccessPolicyForResource", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AccessPolicyEntity>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AccessPolicyEntity) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AccessPolicyEntity)));
        }

        /// <summary>
        /// Deletes an access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="version">The revision is used to verify the client is working with the latest version of the flow. (optional)</param>
        /// <param name="clientId">If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response. (optional)</param>
        /// <param name="disconnectedNodeAcknowledged">Acknowledges that this node is disconnected to allow for mutable requests to proceed. (optional, default to false)</param>
        /// <returns>AccessPolicyEntity</returns>
        public AccessPolicyEntity RemoveAccessPolicy (string id, string version = null, string clientId = null, bool? disconnectedNodeAcknowledged = null)
        {
             ApiResponse<AccessPolicyEntity> localVarResponse = this.RemoveAccessPolicyWithHttpInfo(id, version, clientId, disconnectedNodeAcknowledged);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Deletes an access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="version">The revision is used to verify the client is working with the latest version of the flow. (optional)</param>
        /// <param name="clientId">If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response. (optional)</param>
        /// <param name="disconnectedNodeAcknowledged">Acknowledges that this node is disconnected to allow for mutable requests to proceed. (optional, default to false)</param>
        /// <returns>ApiResponse of AccessPolicyEntity</returns>
        public ApiResponse< AccessPolicyEntity > RemoveAccessPolicyWithHttpInfo (string id, string version = null, string clientId = null, bool? disconnectedNodeAcknowledged = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling PoliciesApi->RemoveAccessPolicy");

            var localVarPath = "/policies/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (version != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "version", version)); // query parameter
            if (clientId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "clientId", clientId)); // query parameter
            if (disconnectedNodeAcknowledged != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "disconnectedNodeAcknowledged", disconnectedNodeAcknowledged)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RemoveAccessPolicy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AccessPolicyEntity>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AccessPolicyEntity) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AccessPolicyEntity)));
        }

        /// <summary>
        /// Deletes an access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="version">The revision is used to verify the client is working with the latest version of the flow. (optional)</param>
        /// <param name="clientId">If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response. (optional)</param>
        /// <param name="disconnectedNodeAcknowledged">Acknowledges that this node is disconnected to allow for mutable requests to proceed. (optional, default to false)</param>
        /// <returns>Task of AccessPolicyEntity</returns>
        public async System.Threading.Tasks.Task<AccessPolicyEntity> RemoveAccessPolicyAsync (string id, string version = null, string clientId = null, bool? disconnectedNodeAcknowledged = null)
        {
             ApiResponse<AccessPolicyEntity> localVarResponse = await this.RemoveAccessPolicyAsyncWithHttpInfo(id, version, clientId, disconnectedNodeAcknowledged);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Deletes an access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="version">The revision is used to verify the client is working with the latest version of the flow. (optional)</param>
        /// <param name="clientId">If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response. (optional)</param>
        /// <param name="disconnectedNodeAcknowledged">Acknowledges that this node is disconnected to allow for mutable requests to proceed. (optional, default to false)</param>
        /// <returns>Task of ApiResponse (AccessPolicyEntity)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AccessPolicyEntity>> RemoveAccessPolicyAsyncWithHttpInfo (string id, string version = null, string clientId = null, bool? disconnectedNodeAcknowledged = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling PoliciesApi->RemoveAccessPolicy");

            var localVarPath = "/policies/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "*/*"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (version != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "version", version)); // query parameter
            if (clientId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "clientId", clientId)); // query parameter
            if (disconnectedNodeAcknowledged != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "disconnectedNodeAcknowledged", disconnectedNodeAcknowledged)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("RemoveAccessPolicy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AccessPolicyEntity>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AccessPolicyEntity) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AccessPolicyEntity)));
        }

        /// <summary>
        /// Updates a access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>AccessPolicyEntity</returns>
        public AccessPolicyEntity UpdateAccessPolicy (string id, AccessPolicyEntity body)
        {
             ApiResponse<AccessPolicyEntity> localVarResponse = this.UpdateAccessPolicyWithHttpInfo(id, body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Updates a access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>ApiResponse of AccessPolicyEntity</returns>
        public ApiResponse< AccessPolicyEntity > UpdateAccessPolicyWithHttpInfo (string id, AccessPolicyEntity body)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling PoliciesApi->UpdateAccessPolicy");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling PoliciesApi->UpdateAccessPolicy");

            var localVarPath = "/policies/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAccessPolicy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AccessPolicyEntity>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AccessPolicyEntity) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AccessPolicyEntity)));
        }

        /// <summary>
        /// Updates a access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>Task of AccessPolicyEntity</returns>
        public async System.Threading.Tasks.Task<AccessPolicyEntity> UpdateAccessPolicyAsync (string id, AccessPolicyEntity body)
        {
             ApiResponse<AccessPolicyEntity> localVarResponse = await this.UpdateAccessPolicyAsyncWithHttpInfo(id, body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Updates a access policy 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The access policy id.</param>
        /// <param name="body">The access policy configuration details.</param>
        /// <returns>Task of ApiResponse (AccessPolicyEntity)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AccessPolicyEntity>> UpdateAccessPolicyAsyncWithHttpInfo (string id, AccessPolicyEntity body)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling PoliciesApi->UpdateAccessPolicy");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling PoliciesApi->UpdateAccessPolicy");

            var localVarPath = "/policies/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAccessPolicy", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AccessPolicyEntity>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AccessPolicyEntity) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AccessPolicyEntity)));
        }

    }
}

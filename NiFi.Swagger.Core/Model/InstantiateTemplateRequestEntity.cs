/* 
 * NiFi Rest Api
 *
 * The Rest Api provides programmatic access to command and control a NiFi instance in real time. Start and                                              stop processors, monitor queues, query provenance data, and more. Each endpoint below includes a description,                                             definitions of the expected input and output, potential response codes, and the authorizations required                                             to invoke each service.
 *
 * OpenAPI spec version: 1.9.1
 * Contact: dev@nifi.apache.org
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

namespace NiFi.Swagger.Core.Model
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations;
    using System.Runtime.Serialization;
    using System.Text;

    using Newtonsoft.Json;

    /// <summary>
    /// InstantiateTemplateRequestEntity
    /// </summary>
    [DataContract]
    public partial class InstantiateTemplateRequestEntity :  IEquatable<InstantiateTemplateRequestEntity>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="InstantiateTemplateRequestEntity" /> class.
        /// </summary>
        /// <param name="originX">The x coordinate of the origin of the bounding box where the new components will be placed..</param>
        /// <param name="originY">The y coordinate of the origin of the bounding box where the new components will be placed..</param>
        /// <param name="templateId">The identifier of the template..</param>
        /// <param name="encodingVersion">The encoding version of the flow snippet. If not specified, this is automatically populated by the node receiving the user request. If the snippet is specified, the version will be the latest. If the snippet is not specified, the version will come from the underlying template. These details need to be replicated throughout the cluster to ensure consistency..</param>
        /// <param name="snippet">A flow snippet of the template contents. If not specified, this is automatically populated by the node receiving the user request. These details need to be replicated throughout the cluster to ensure consistency..</param>
        /// <param name="disconnectedNodeAcknowledged">Acknowledges that this node is disconnected to allow for mutable requests to proceed..</param>
        public InstantiateTemplateRequestEntity(double? originX = default(double?), double? originY = default(double?), string templateId = default(string), string encodingVersion = default(string), FlowSnippetDTO snippet = default(FlowSnippetDTO), bool? disconnectedNodeAcknowledged = default(bool?))
        {
            this.OriginX = originX;
            this.OriginY = originY;
            this.TemplateId = templateId;
            this.EncodingVersion = encodingVersion;
            this.Snippet = snippet;
            this.DisconnectedNodeAcknowledged = disconnectedNodeAcknowledged;
        }
        
        /// <summary>
        /// The x coordinate of the origin of the bounding box where the new components will be placed.
        /// </summary>
        /// <value>The x coordinate of the origin of the bounding box where the new components will be placed.</value>
        [DataMember(Name="originX", EmitDefaultValue=false)]
        public double? OriginX { get; set; }

        /// <summary>
        /// The y coordinate of the origin of the bounding box where the new components will be placed.
        /// </summary>
        /// <value>The y coordinate of the origin of the bounding box where the new components will be placed.</value>
        [DataMember(Name="originY", EmitDefaultValue=false)]
        public double? OriginY { get; set; }

        /// <summary>
        /// The identifier of the template.
        /// </summary>
        /// <value>The identifier of the template.</value>
        [DataMember(Name="templateId", EmitDefaultValue=false)]
        public string TemplateId { get; set; }

        /// <summary>
        /// The encoding version of the flow snippet. If not specified, this is automatically populated by the node receiving the user request. If the snippet is specified, the version will be the latest. If the snippet is not specified, the version will come from the underlying template. These details need to be replicated throughout the cluster to ensure consistency.
        /// </summary>
        /// <value>The encoding version of the flow snippet. If not specified, this is automatically populated by the node receiving the user request. If the snippet is specified, the version will be the latest. If the snippet is not specified, the version will come from the underlying template. These details need to be replicated throughout the cluster to ensure consistency.</value>
        [DataMember(Name="encodingVersion", EmitDefaultValue=false)]
        public string EncodingVersion { get; set; }

        /// <summary>
        /// A flow snippet of the template contents. If not specified, this is automatically populated by the node receiving the user request. These details need to be replicated throughout the cluster to ensure consistency.
        /// </summary>
        /// <value>A flow snippet of the template contents. If not specified, this is automatically populated by the node receiving the user request. These details need to be replicated throughout the cluster to ensure consistency.</value>
        [DataMember(Name="snippet", EmitDefaultValue=false)]
        public FlowSnippetDTO Snippet { get; set; }

        /// <summary>
        /// Acknowledges that this node is disconnected to allow for mutable requests to proceed.
        /// </summary>
        /// <value>Acknowledges that this node is disconnected to allow for mutable requests to proceed.</value>
        [DataMember(Name="disconnectedNodeAcknowledged", EmitDefaultValue=false)]
        public bool? DisconnectedNodeAcknowledged { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class InstantiateTemplateRequestEntity {\n");
            sb.Append("  OriginX: ").Append(this.OriginX).Append("\n");
            sb.Append("  OriginY: ").Append(this.OriginY).Append("\n");
            sb.Append("  TemplateId: ").Append(this.TemplateId).Append("\n");
            sb.Append("  EncodingVersion: ").Append(this.EncodingVersion).Append("\n");
            sb.Append("  Snippet: ").Append(this.Snippet).Append("\n");
            sb.Append("  DisconnectedNodeAcknowledged: ").Append(this.DisconnectedNodeAcknowledged).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as InstantiateTemplateRequestEntity);
        }

        /// <summary>
        /// Returns true if InstantiateTemplateRequestEntity instances are equal
        /// </summary>
        /// <param name="input">Instance of InstantiateTemplateRequestEntity to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(InstantiateTemplateRequestEntity input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.OriginX == input.OriginX ||
                    (this.OriginX != null &&
                    this.OriginX.Equals(input.OriginX))
                ) && 
                (
                    this.OriginY == input.OriginY ||
                    (this.OriginY != null &&
                    this.OriginY.Equals(input.OriginY))
                ) && 
                (
                    this.TemplateId == input.TemplateId ||
                    (this.TemplateId != null &&
                    this.TemplateId.Equals(input.TemplateId))
                ) && 
                (
                    this.EncodingVersion == input.EncodingVersion ||
                    (this.EncodingVersion != null &&
                    this.EncodingVersion.Equals(input.EncodingVersion))
                ) && 
                (
                    this.Snippet == input.Snippet ||
                    (this.Snippet != null &&
                    this.Snippet.Equals(input.Snippet))
                ) && 
                (
                    this.DisconnectedNodeAcknowledged == input.DisconnectedNodeAcknowledged ||
                    (this.DisconnectedNodeAcknowledged != null &&
                    this.DisconnectedNodeAcknowledged.Equals(input.DisconnectedNodeAcknowledged))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.OriginX != null)
                    hashCode = hashCode * 59 + this.OriginX.GetHashCode();
                if (this.OriginY != null)
                    hashCode = hashCode * 59 + this.OriginY.GetHashCode();
                if (this.TemplateId != null)
                    hashCode = hashCode * 59 + this.TemplateId.GetHashCode();
                if (this.EncodingVersion != null)
                    hashCode = hashCode * 59 + this.EncodingVersion.GetHashCode();
                if (this.Snippet != null)
                    hashCode = hashCode * 59 + this.Snippet.GetHashCode();
                if (this.DisconnectedNodeAcknowledged != null)
                    hashCode = hashCode * 59 + this.DisconnectedNodeAcknowledged.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}

/* 
 * NiFi Rest Api
 *
 * The Rest Api provides programmatic access to command and control a NiFi instance in real time. Start and                                              stop processors, monitor queues, query provenance data, and more. Each endpoint below includes a description,                                             definitions of the expected input and output, potential response codes, and the authorizations required                                             to invoke each service.
 *
 * OpenAPI spec version: 1.9.1
 * Contact: dev@nifi.apache.org
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

namespace NiFi.Swagger.Core.Model
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations;
    using System.Linq;
    using System.Runtime.Serialization;
    using System.Text;

    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    /// <summary>
    /// VersionedProcessor
    /// </summary>
    [DataContract]
    public partial class VersionedProcessor :  IEquatable<VersionedProcessor>, IValidatableObject
    {
        /// <summary>
        /// Defines ComponentType
        /// </summary>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ComponentTypeEnum
        {
            
            /// <summary>
            /// Enum CONNECTION for value: CONNECTION
            /// </summary>
            [EnumMember(Value = "CONNECTION")]
            CONNECTION = 1,
            
            /// <summary>
            /// Enum PROCESSOR for value: PROCESSOR
            /// </summary>
            [EnumMember(Value = "PROCESSOR")]
            PROCESSOR = 2,
            
            /// <summary>
            /// Enum PROCESSGROUP for value: PROCESS_GROUP
            /// </summary>
            [EnumMember(Value = "PROCESS_GROUP")]
            PROCESSGROUP = 3,
            
            /// <summary>
            /// Enum REMOTEPROCESSGROUP for value: REMOTE_PROCESS_GROUP
            /// </summary>
            [EnumMember(Value = "REMOTE_PROCESS_GROUP")]
            REMOTEPROCESSGROUP = 4,
            
            /// <summary>
            /// Enum INPUTPORT for value: INPUT_PORT
            /// </summary>
            [EnumMember(Value = "INPUT_PORT")]
            INPUTPORT = 5,
            
            /// <summary>
            /// Enum OUTPUTPORT for value: OUTPUT_PORT
            /// </summary>
            [EnumMember(Value = "OUTPUT_PORT")]
            OUTPUTPORT = 6,
            
            /// <summary>
            /// Enum REMOTEINPUTPORT for value: REMOTE_INPUT_PORT
            /// </summary>
            [EnumMember(Value = "REMOTE_INPUT_PORT")]
            REMOTEINPUTPORT = 7,
            
            /// <summary>
            /// Enum REMOTEOUTPUTPORT for value: REMOTE_OUTPUT_PORT
            /// </summary>
            [EnumMember(Value = "REMOTE_OUTPUT_PORT")]
            REMOTEOUTPUTPORT = 8,
            
            /// <summary>
            /// Enum FUNNEL for value: FUNNEL
            /// </summary>
            [EnumMember(Value = "FUNNEL")]
            FUNNEL = 9,
            
            /// <summary>
            /// Enum LABEL for value: LABEL
            /// </summary>
            [EnumMember(Value = "LABEL")]
            LABEL = 10,
            
            /// <summary>
            /// Enum CONTROLLERSERVICE for value: CONTROLLER_SERVICE
            /// </summary>
            [EnumMember(Value = "CONTROLLER_SERVICE")]
            CONTROLLERSERVICE = 11
        }

        /// <summary>
        /// Gets or Sets ComponentType
        /// </summary>
        [DataMember(Name="componentType", EmitDefaultValue=false)]
        public ComponentTypeEnum? ComponentType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="VersionedProcessor" /> class.
        /// </summary>
        /// <param name="identifier">The component&#39;s unique identifier.</param>
        /// <param name="name">The component&#39;s name.</param>
        /// <param name="comments">The user-supplied comments for the component.</param>
        /// <param name="position">The component&#39;s position on the graph.</param>
        /// <param name="bundle">Information about the bundle from which the component came.</param>
        /// <param name="style">Stylistic data for rendering in a UI.</param>
        /// <param name="type">The type of Processor.</param>
        /// <param name="properties">The properties for the processor. Properties whose value is not set will only contain the property name..</param>
        /// <param name="propertyDescriptors">The property descriptors for the processor..</param>
        /// <param name="annotationData">The annotation data for the processor used to relay configuration between a custom UI and the procesosr..</param>
        /// <param name="schedulingPeriod">The frequency with which to schedule the processor. The format of the value will depend on th value of schedulingStrategy..</param>
        /// <param name="schedulingStrategy">Indcates whether the prcessor should be scheduled to run in event or timer driven mode..</param>
        /// <param name="executionNode">Indicates the node where the process will execute..</param>
        /// <param name="penaltyDuration">The amout of time that is used when the process penalizes a flowfile..</param>
        /// <param name="yieldDuration">The amount of time that must elapse before this processor is scheduled again after yielding..</param>
        /// <param name="bulletinLevel">The level at which the processor will report bulletins..</param>
        /// <param name="runDurationMillis">The run duration for the processor in milliseconds..</param>
        /// <param name="concurrentlySchedulableTaskCount">The number of tasks that should be concurrently schedule for the processor. If the processor doesn&#39;t allow parallol processing then any positive input will be ignored..</param>
        /// <param name="autoTerminatedRelationships">The names of all relationships that cause a flow file to be terminated if the relationship is not connected elsewhere. This property differs from the &#39;isAutoTerminate&#39; property of the RelationshipDTO in that the RelationshipDTO is meant to depict the current configuration, whereas this property can be set in a DTO when updating a Processor in order to change which Relationships should be auto-terminated..</param>
        /// <param name="componentType">componentType.</param>
        /// <param name="groupIdentifier">The ID of the Process Group that this component belongs to.</param>
        public VersionedProcessor(string identifier = default(string), string name = default(string), string comments = default(string), Position position = default(Position), Bundle bundle = default(Bundle), Dictionary<string, string> style = default(Dictionary<string, string>), string type = default(string), Dictionary<string, string> properties = default(Dictionary<string, string>), Dictionary<string, VersionedPropertyDescriptor> propertyDescriptors = default(Dictionary<string, VersionedPropertyDescriptor>), string annotationData = default(string), string schedulingPeriod = default(string), string schedulingStrategy = default(string), string executionNode = default(string), string penaltyDuration = default(string), string yieldDuration = default(string), string bulletinLevel = default(string), long? runDurationMillis = default(long?), int? concurrentlySchedulableTaskCount = default(int?), List<string> autoTerminatedRelationships = default(List<string>), ComponentTypeEnum? componentType = default(ComponentTypeEnum?), string groupIdentifier = default(string))
        {
            this.Identifier = identifier;
            this.Name = name;
            this.Comments = comments;
            this.Position = position;
            this.Bundle = bundle;
            this.Style = style;
            this.Type = type;
            this.Properties = properties;
            this.PropertyDescriptors = propertyDescriptors;
            this.AnnotationData = annotationData;
            this.SchedulingPeriod = schedulingPeriod;
            this.SchedulingStrategy = schedulingStrategy;
            this.ExecutionNode = executionNode;
            this.PenaltyDuration = penaltyDuration;
            this.YieldDuration = yieldDuration;
            this.BulletinLevel = bulletinLevel;
            this.RunDurationMillis = runDurationMillis;
            this.ConcurrentlySchedulableTaskCount = concurrentlySchedulableTaskCount;
            this.AutoTerminatedRelationships = autoTerminatedRelationships;
            this.ComponentType = componentType;
            this.GroupIdentifier = groupIdentifier;
        }
        
        /// <summary>
        /// The component&#39;s unique identifier
        /// </summary>
        /// <value>The component&#39;s unique identifier</value>
        [DataMember(Name="identifier", EmitDefaultValue=false)]
        public string Identifier { get; set; }

        /// <summary>
        /// The component&#39;s name
        /// </summary>
        /// <value>The component&#39;s name</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// The user-supplied comments for the component
        /// </summary>
        /// <value>The user-supplied comments for the component</value>
        [DataMember(Name="comments", EmitDefaultValue=false)]
        public string Comments { get; set; }

        /// <summary>
        /// The component&#39;s position on the graph
        /// </summary>
        /// <value>The component&#39;s position on the graph</value>
        [DataMember(Name="position", EmitDefaultValue=false)]
        public Position Position { get; set; }

        /// <summary>
        /// Information about the bundle from which the component came
        /// </summary>
        /// <value>Information about the bundle from which the component came</value>
        [DataMember(Name="bundle", EmitDefaultValue=false)]
        public Bundle Bundle { get; set; }

        /// <summary>
        /// Stylistic data for rendering in a UI
        /// </summary>
        /// <value>Stylistic data for rendering in a UI</value>
        [DataMember(Name="style", EmitDefaultValue=false)]
        public Dictionary<string, string> Style { get; set; }

        /// <summary>
        /// The type of Processor
        /// </summary>
        /// <value>The type of Processor</value>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public string Type { get; set; }

        /// <summary>
        /// The properties for the processor. Properties whose value is not set will only contain the property name.
        /// </summary>
        /// <value>The properties for the processor. Properties whose value is not set will only contain the property name.</value>
        [DataMember(Name="properties", EmitDefaultValue=false)]
        public Dictionary<string, string> Properties { get; set; }

        /// <summary>
        /// The property descriptors for the processor.
        /// </summary>
        /// <value>The property descriptors for the processor.</value>
        [DataMember(Name="propertyDescriptors", EmitDefaultValue=false)]
        public Dictionary<string, VersionedPropertyDescriptor> PropertyDescriptors { get; set; }

        /// <summary>
        /// The annotation data for the processor used to relay configuration between a custom UI and the procesosr.
        /// </summary>
        /// <value>The annotation data for the processor used to relay configuration between a custom UI and the procesosr.</value>
        [DataMember(Name="annotationData", EmitDefaultValue=false)]
        public string AnnotationData { get; set; }

        /// <summary>
        /// The frequency with which to schedule the processor. The format of the value will depend on th value of schedulingStrategy.
        /// </summary>
        /// <value>The frequency with which to schedule the processor. The format of the value will depend on th value of schedulingStrategy.</value>
        [DataMember(Name="schedulingPeriod", EmitDefaultValue=false)]
        public string SchedulingPeriod { get; set; }

        /// <summary>
        /// Indcates whether the prcessor should be scheduled to run in event or timer driven mode.
        /// </summary>
        /// <value>Indcates whether the prcessor should be scheduled to run in event or timer driven mode.</value>
        [DataMember(Name="schedulingStrategy", EmitDefaultValue=false)]
        public string SchedulingStrategy { get; set; }

        /// <summary>
        /// Indicates the node where the process will execute.
        /// </summary>
        /// <value>Indicates the node where the process will execute.</value>
        [DataMember(Name="executionNode", EmitDefaultValue=false)]
        public string ExecutionNode { get; set; }

        /// <summary>
        /// The amout of time that is used when the process penalizes a flowfile.
        /// </summary>
        /// <value>The amout of time that is used when the process penalizes a flowfile.</value>
        [DataMember(Name="penaltyDuration", EmitDefaultValue=false)]
        public string PenaltyDuration { get; set; }

        /// <summary>
        /// The amount of time that must elapse before this processor is scheduled again after yielding.
        /// </summary>
        /// <value>The amount of time that must elapse before this processor is scheduled again after yielding.</value>
        [DataMember(Name="yieldDuration", EmitDefaultValue=false)]
        public string YieldDuration { get; set; }

        /// <summary>
        /// The level at which the processor will report bulletins.
        /// </summary>
        /// <value>The level at which the processor will report bulletins.</value>
        [DataMember(Name="bulletinLevel", EmitDefaultValue=false)]
        public string BulletinLevel { get; set; }

        /// <summary>
        /// The run duration for the processor in milliseconds.
        /// </summary>
        /// <value>The run duration for the processor in milliseconds.</value>
        [DataMember(Name="runDurationMillis", EmitDefaultValue=false)]
        public long? RunDurationMillis { get; set; }

        /// <summary>
        /// The number of tasks that should be concurrently schedule for the processor. If the processor doesn&#39;t allow parallol processing then any positive input will be ignored.
        /// </summary>
        /// <value>The number of tasks that should be concurrently schedule for the processor. If the processor doesn&#39;t allow parallol processing then any positive input will be ignored.</value>
        [DataMember(Name="concurrentlySchedulableTaskCount", EmitDefaultValue=false)]
        public int? ConcurrentlySchedulableTaskCount { get; set; }

        /// <summary>
        /// The names of all relationships that cause a flow file to be terminated if the relationship is not connected elsewhere. This property differs from the &#39;isAutoTerminate&#39; property of the RelationshipDTO in that the RelationshipDTO is meant to depict the current configuration, whereas this property can be set in a DTO when updating a Processor in order to change which Relationships should be auto-terminated.
        /// </summary>
        /// <value>The names of all relationships that cause a flow file to be terminated if the relationship is not connected elsewhere. This property differs from the &#39;isAutoTerminate&#39; property of the RelationshipDTO in that the RelationshipDTO is meant to depict the current configuration, whereas this property can be set in a DTO when updating a Processor in order to change which Relationships should be auto-terminated.</value>
        [DataMember(Name="autoTerminatedRelationships", EmitDefaultValue=false)]
        public List<string> AutoTerminatedRelationships { get; set; }


        /// <summary>
        /// The ID of the Process Group that this component belongs to
        /// </summary>
        /// <value>The ID of the Process Group that this component belongs to</value>
        [DataMember(Name="groupIdentifier", EmitDefaultValue=false)]
        public string GroupIdentifier { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class VersionedProcessor {\n");
            sb.Append("  Identifier: ").Append(this.Identifier).Append("\n");
            sb.Append("  Name: ").Append(this.Name).Append("\n");
            sb.Append("  Comments: ").Append(this.Comments).Append("\n");
            sb.Append("  Position: ").Append(this.Position).Append("\n");
            sb.Append("  Bundle: ").Append(this.Bundle).Append("\n");
            sb.Append("  Style: ").Append(this.Style).Append("\n");
            sb.Append("  Type: ").Append(this.Type).Append("\n");
            sb.Append("  Properties: ").Append(this.Properties).Append("\n");
            sb.Append("  PropertyDescriptors: ").Append(this.PropertyDescriptors).Append("\n");
            sb.Append("  AnnotationData: ").Append(this.AnnotationData).Append("\n");
            sb.Append("  SchedulingPeriod: ").Append(this.SchedulingPeriod).Append("\n");
            sb.Append("  SchedulingStrategy: ").Append(this.SchedulingStrategy).Append("\n");
            sb.Append("  ExecutionNode: ").Append(this.ExecutionNode).Append("\n");
            sb.Append("  PenaltyDuration: ").Append(this.PenaltyDuration).Append("\n");
            sb.Append("  YieldDuration: ").Append(this.YieldDuration).Append("\n");
            sb.Append("  BulletinLevel: ").Append(this.BulletinLevel).Append("\n");
            sb.Append("  RunDurationMillis: ").Append(this.RunDurationMillis).Append("\n");
            sb.Append("  ConcurrentlySchedulableTaskCount: ").Append(this.ConcurrentlySchedulableTaskCount).Append("\n");
            sb.Append("  AutoTerminatedRelationships: ").Append(this.AutoTerminatedRelationships).Append("\n");
            sb.Append("  ComponentType: ").Append(this.ComponentType).Append("\n");
            sb.Append("  GroupIdentifier: ").Append(this.GroupIdentifier).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as VersionedProcessor);
        }

        /// <summary>
        /// Returns true if VersionedProcessor instances are equal
        /// </summary>
        /// <param name="input">Instance of VersionedProcessor to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(VersionedProcessor input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Identifier == input.Identifier ||
                    (this.Identifier != null &&
                    this.Identifier.Equals(input.Identifier))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.Comments == input.Comments ||
                    (this.Comments != null &&
                    this.Comments.Equals(input.Comments))
                ) && 
                (
                    this.Position == input.Position ||
                    (this.Position != null &&
                    this.Position.Equals(input.Position))
                ) && 
                (
                    this.Bundle == input.Bundle ||
                    (this.Bundle != null &&
                    this.Bundle.Equals(input.Bundle))
                ) && 
                (
                    this.Style == input.Style ||
                    this.Style != null &&
                    this.Style.SequenceEqual(input.Style)
                ) && 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && 
                (
                    this.Properties == input.Properties ||
                    this.Properties != null &&
                    this.Properties.SequenceEqual(input.Properties)
                ) && 
                (
                    this.PropertyDescriptors == input.PropertyDescriptors ||
                    this.PropertyDescriptors != null &&
                    this.PropertyDescriptors.SequenceEqual(input.PropertyDescriptors)
                ) && 
                (
                    this.AnnotationData == input.AnnotationData ||
                    (this.AnnotationData != null &&
                    this.AnnotationData.Equals(input.AnnotationData))
                ) && 
                (
                    this.SchedulingPeriod == input.SchedulingPeriod ||
                    (this.SchedulingPeriod != null &&
                    this.SchedulingPeriod.Equals(input.SchedulingPeriod))
                ) && 
                (
                    this.SchedulingStrategy == input.SchedulingStrategy ||
                    (this.SchedulingStrategy != null &&
                    this.SchedulingStrategy.Equals(input.SchedulingStrategy))
                ) && 
                (
                    this.ExecutionNode == input.ExecutionNode ||
                    (this.ExecutionNode != null &&
                    this.ExecutionNode.Equals(input.ExecutionNode))
                ) && 
                (
                    this.PenaltyDuration == input.PenaltyDuration ||
                    (this.PenaltyDuration != null &&
                    this.PenaltyDuration.Equals(input.PenaltyDuration))
                ) && 
                (
                    this.YieldDuration == input.YieldDuration ||
                    (this.YieldDuration != null &&
                    this.YieldDuration.Equals(input.YieldDuration))
                ) && 
                (
                    this.BulletinLevel == input.BulletinLevel ||
                    (this.BulletinLevel != null &&
                    this.BulletinLevel.Equals(input.BulletinLevel))
                ) && 
                (
                    this.RunDurationMillis == input.RunDurationMillis ||
                    (this.RunDurationMillis != null &&
                    this.RunDurationMillis.Equals(input.RunDurationMillis))
                ) && 
                (
                    this.ConcurrentlySchedulableTaskCount == input.ConcurrentlySchedulableTaskCount ||
                    (this.ConcurrentlySchedulableTaskCount != null &&
                    this.ConcurrentlySchedulableTaskCount.Equals(input.ConcurrentlySchedulableTaskCount))
                ) && 
                (
                    this.AutoTerminatedRelationships == input.AutoTerminatedRelationships ||
                    this.AutoTerminatedRelationships != null &&
                    this.AutoTerminatedRelationships.SequenceEqual(input.AutoTerminatedRelationships)
                ) && 
                (
                    this.ComponentType == input.ComponentType ||
                    (this.ComponentType != null &&
                    this.ComponentType.Equals(input.ComponentType))
                ) && 
                (
                    this.GroupIdentifier == input.GroupIdentifier ||
                    (this.GroupIdentifier != null &&
                    this.GroupIdentifier.Equals(input.GroupIdentifier))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Identifier != null)
                    hashCode = hashCode * 59 + this.Identifier.GetHashCode();
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.Comments != null)
                    hashCode = hashCode * 59 + this.Comments.GetHashCode();
                if (this.Position != null)
                    hashCode = hashCode * 59 + this.Position.GetHashCode();
                if (this.Bundle != null)
                    hashCode = hashCode * 59 + this.Bundle.GetHashCode();
                if (this.Style != null)
                    hashCode = hashCode * 59 + this.Style.GetHashCode();
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.Properties != null)
                    hashCode = hashCode * 59 + this.Properties.GetHashCode();
                if (this.PropertyDescriptors != null)
                    hashCode = hashCode * 59 + this.PropertyDescriptors.GetHashCode();
                if (this.AnnotationData != null)
                    hashCode = hashCode * 59 + this.AnnotationData.GetHashCode();
                if (this.SchedulingPeriod != null)
                    hashCode = hashCode * 59 + this.SchedulingPeriod.GetHashCode();
                if (this.SchedulingStrategy != null)
                    hashCode = hashCode * 59 + this.SchedulingStrategy.GetHashCode();
                if (this.ExecutionNode != null)
                    hashCode = hashCode * 59 + this.ExecutionNode.GetHashCode();
                if (this.PenaltyDuration != null)
                    hashCode = hashCode * 59 + this.PenaltyDuration.GetHashCode();
                if (this.YieldDuration != null)
                    hashCode = hashCode * 59 + this.YieldDuration.GetHashCode();
                if (this.BulletinLevel != null)
                    hashCode = hashCode * 59 + this.BulletinLevel.GetHashCode();
                if (this.RunDurationMillis != null)
                    hashCode = hashCode * 59 + this.RunDurationMillis.GetHashCode();
                if (this.ConcurrentlySchedulableTaskCount != null)
                    hashCode = hashCode * 59 + this.ConcurrentlySchedulableTaskCount.GetHashCode();
                if (this.AutoTerminatedRelationships != null)
                    hashCode = hashCode * 59 + this.AutoTerminatedRelationships.GetHashCode();
                if (this.ComponentType != null)
                    hashCode = hashCode * 59 + this.ComponentType.GetHashCode();
                if (this.GroupIdentifier != null)
                    hashCode = hashCode * 59 + this.GroupIdentifier.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}

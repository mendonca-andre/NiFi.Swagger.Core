/* 
 * NiFi Rest Api
 *
 * The Rest Api provides programmatic access to command and control a NiFi instance in real time. Start and                                              stop processors, monitor queues, query provenance data, and more. Each endpoint below includes a description,                                             definitions of the expected input and output, potential response codes, and the authorizations required                                             to invoke each service.
 *
 * OpenAPI spec version: 1.9.1
 * Contact: dev@nifi.apache.org
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

namespace NiFi.Swagger.Core.Model
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations;
    using System.Linq;
    using System.Runtime.Serialization;
    using System.Text;

    using Newtonsoft.Json;

    /// <summary>
    /// SystemDiagnosticsSnapshotDTO
    /// </summary>
    [DataContract]
    public partial class SystemDiagnosticsSnapshotDTO :  IEquatable<SystemDiagnosticsSnapshotDTO>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SystemDiagnosticsSnapshotDTO" /> class.
        /// </summary>
        /// <param name="totalNonHeap">Total size of non heap..</param>
        /// <param name="totalNonHeapBytes">Total number of bytes allocated to the JVM not used for heap.</param>
        /// <param name="usedNonHeap">Amount of use non heap..</param>
        /// <param name="usedNonHeapBytes">Total number of bytes used by the JVM not in the heap space.</param>
        /// <param name="freeNonHeap">Amount of free non heap..</param>
        /// <param name="freeNonHeapBytes">Total number of free non-heap bytes available to the JVM.</param>
        /// <param name="maxNonHeap">Maximum size of non heap..</param>
        /// <param name="maxNonHeapBytes">The maximum number of bytes that the JVM can use for non-heap purposes.</param>
        /// <param name="nonHeapUtilization">Utilization of non heap..</param>
        /// <param name="totalHeap">Total size of heap..</param>
        /// <param name="totalHeapBytes">The total number of bytes that are available for the JVM heap to use.</param>
        /// <param name="usedHeap">Amount of used heap..</param>
        /// <param name="usedHeapBytes">The number of bytes of JVM heap that are currently being used.</param>
        /// <param name="freeHeap">Amount of free heap..</param>
        /// <param name="freeHeapBytes">The number of bytes that are allocated to the JVM heap but not currently being used.</param>
        /// <param name="maxHeap">Maximum size of heap..</param>
        /// <param name="maxHeapBytes">The maximum number of bytes that can be used by the JVM.</param>
        /// <param name="heapUtilization">Utilization of heap..</param>
        /// <param name="availableProcessors">Number of available processors if supported by the underlying system..</param>
        /// <param name="processorLoadAverage">The processor load average if supported by the underlying system..</param>
        /// <param name="totalThreads">Total number of threads..</param>
        /// <param name="daemonThreads">Number of daemon threads..</param>
        /// <param name="uptime">The uptime of the Java virtual machine.</param>
        /// <param name="flowFileRepositoryStorageUsage">The flowfile repository storage usage..</param>
        /// <param name="contentRepositoryStorageUsage">The content repository storage usage..</param>
        /// <param name="provenanceRepositoryStorageUsage">The provenance repository storage usage..</param>
        /// <param name="garbageCollection">The garbage collection details..</param>
        /// <param name="statsLastRefreshed">When the diagnostics were generated..</param>
        /// <param name="versionInfo">The nifi, os, java, and build version information.</param>
        public SystemDiagnosticsSnapshotDTO(string totalNonHeap = default(string), long? totalNonHeapBytes = default(long?), string usedNonHeap = default(string), long? usedNonHeapBytes = default(long?), string freeNonHeap = default(string), long? freeNonHeapBytes = default(long?), string maxNonHeap = default(string), long? maxNonHeapBytes = default(long?), string nonHeapUtilization = default(string), string totalHeap = default(string), long? totalHeapBytes = default(long?), string usedHeap = default(string), long? usedHeapBytes = default(long?), string freeHeap = default(string), long? freeHeapBytes = default(long?), string maxHeap = default(string), long? maxHeapBytes = default(long?), string heapUtilization = default(string), int? availableProcessors = default(int?), double? processorLoadAverage = default(double?), int? totalThreads = default(int?), int? daemonThreads = default(int?), string uptime = default(string), StorageUsageDTO flowFileRepositoryStorageUsage = default(StorageUsageDTO), List<StorageUsageDTO> contentRepositoryStorageUsage = default(List<StorageUsageDTO>), List<StorageUsageDTO> provenanceRepositoryStorageUsage = default(List<StorageUsageDTO>), List<GarbageCollectionDTO> garbageCollection = default(List<GarbageCollectionDTO>), string statsLastRefreshed = default(string), VersionInfoDTO versionInfo = default(VersionInfoDTO))
        {
            this.TotalNonHeap = totalNonHeap;
            this.TotalNonHeapBytes = totalNonHeapBytes;
            this.UsedNonHeap = usedNonHeap;
            this.UsedNonHeapBytes = usedNonHeapBytes;
            this.FreeNonHeap = freeNonHeap;
            this.FreeNonHeapBytes = freeNonHeapBytes;
            this.MaxNonHeap = maxNonHeap;
            this.MaxNonHeapBytes = maxNonHeapBytes;
            this.NonHeapUtilization = nonHeapUtilization;
            this.TotalHeap = totalHeap;
            this.TotalHeapBytes = totalHeapBytes;
            this.UsedHeap = usedHeap;
            this.UsedHeapBytes = usedHeapBytes;
            this.FreeHeap = freeHeap;
            this.FreeHeapBytes = freeHeapBytes;
            this.MaxHeap = maxHeap;
            this.MaxHeapBytes = maxHeapBytes;
            this.HeapUtilization = heapUtilization;
            this.AvailableProcessors = availableProcessors;
            this.ProcessorLoadAverage = processorLoadAverage;
            this.TotalThreads = totalThreads;
            this.DaemonThreads = daemonThreads;
            this.Uptime = uptime;
            this.FlowFileRepositoryStorageUsage = flowFileRepositoryStorageUsage;
            this.ContentRepositoryStorageUsage = contentRepositoryStorageUsage;
            this.ProvenanceRepositoryStorageUsage = provenanceRepositoryStorageUsage;
            this.GarbageCollection = garbageCollection;
            this.StatsLastRefreshed = statsLastRefreshed;
            this.VersionInfo = versionInfo;
        }
        
        /// <summary>
        /// Total size of non heap.
        /// </summary>
        /// <value>Total size of non heap.</value>
        [DataMember(Name="totalNonHeap", EmitDefaultValue=false)]
        public string TotalNonHeap { get; set; }

        /// <summary>
        /// Total number of bytes allocated to the JVM not used for heap
        /// </summary>
        /// <value>Total number of bytes allocated to the JVM not used for heap</value>
        [DataMember(Name="totalNonHeapBytes", EmitDefaultValue=false)]
        public long? TotalNonHeapBytes { get; set; }

        /// <summary>
        /// Amount of use non heap.
        /// </summary>
        /// <value>Amount of use non heap.</value>
        [DataMember(Name="usedNonHeap", EmitDefaultValue=false)]
        public string UsedNonHeap { get; set; }

        /// <summary>
        /// Total number of bytes used by the JVM not in the heap space
        /// </summary>
        /// <value>Total number of bytes used by the JVM not in the heap space</value>
        [DataMember(Name="usedNonHeapBytes", EmitDefaultValue=false)]
        public long? UsedNonHeapBytes { get; set; }

        /// <summary>
        /// Amount of free non heap.
        /// </summary>
        /// <value>Amount of free non heap.</value>
        [DataMember(Name="freeNonHeap", EmitDefaultValue=false)]
        public string FreeNonHeap { get; set; }

        /// <summary>
        /// Total number of free non-heap bytes available to the JVM
        /// </summary>
        /// <value>Total number of free non-heap bytes available to the JVM</value>
        [DataMember(Name="freeNonHeapBytes", EmitDefaultValue=false)]
        public long? FreeNonHeapBytes { get; set; }

        /// <summary>
        /// Maximum size of non heap.
        /// </summary>
        /// <value>Maximum size of non heap.</value>
        [DataMember(Name="maxNonHeap", EmitDefaultValue=false)]
        public string MaxNonHeap { get; set; }

        /// <summary>
        /// The maximum number of bytes that the JVM can use for non-heap purposes
        /// </summary>
        /// <value>The maximum number of bytes that the JVM can use for non-heap purposes</value>
        [DataMember(Name="maxNonHeapBytes", EmitDefaultValue=false)]
        public long? MaxNonHeapBytes { get; set; }

        /// <summary>
        /// Utilization of non heap.
        /// </summary>
        /// <value>Utilization of non heap.</value>
        [DataMember(Name="nonHeapUtilization", EmitDefaultValue=false)]
        public string NonHeapUtilization { get; set; }

        /// <summary>
        /// Total size of heap.
        /// </summary>
        /// <value>Total size of heap.</value>
        [DataMember(Name="totalHeap", EmitDefaultValue=false)]
        public string TotalHeap { get; set; }

        /// <summary>
        /// The total number of bytes that are available for the JVM heap to use
        /// </summary>
        /// <value>The total number of bytes that are available for the JVM heap to use</value>
        [DataMember(Name="totalHeapBytes", EmitDefaultValue=false)]
        public long? TotalHeapBytes { get; set; }

        /// <summary>
        /// Amount of used heap.
        /// </summary>
        /// <value>Amount of used heap.</value>
        [DataMember(Name="usedHeap", EmitDefaultValue=false)]
        public string UsedHeap { get; set; }

        /// <summary>
        /// The number of bytes of JVM heap that are currently being used
        /// </summary>
        /// <value>The number of bytes of JVM heap that are currently being used</value>
        [DataMember(Name="usedHeapBytes", EmitDefaultValue=false)]
        public long? UsedHeapBytes { get; set; }

        /// <summary>
        /// Amount of free heap.
        /// </summary>
        /// <value>Amount of free heap.</value>
        [DataMember(Name="freeHeap", EmitDefaultValue=false)]
        public string FreeHeap { get; set; }

        /// <summary>
        /// The number of bytes that are allocated to the JVM heap but not currently being used
        /// </summary>
        /// <value>The number of bytes that are allocated to the JVM heap but not currently being used</value>
        [DataMember(Name="freeHeapBytes", EmitDefaultValue=false)]
        public long? FreeHeapBytes { get; set; }

        /// <summary>
        /// Maximum size of heap.
        /// </summary>
        /// <value>Maximum size of heap.</value>
        [DataMember(Name="maxHeap", EmitDefaultValue=false)]
        public string MaxHeap { get; set; }

        /// <summary>
        /// The maximum number of bytes that can be used by the JVM
        /// </summary>
        /// <value>The maximum number of bytes that can be used by the JVM</value>
        [DataMember(Name="maxHeapBytes", EmitDefaultValue=false)]
        public long? MaxHeapBytes { get; set; }

        /// <summary>
        /// Utilization of heap.
        /// </summary>
        /// <value>Utilization of heap.</value>
        [DataMember(Name="heapUtilization", EmitDefaultValue=false)]
        public string HeapUtilization { get; set; }

        /// <summary>
        /// Number of available processors if supported by the underlying system.
        /// </summary>
        /// <value>Number of available processors if supported by the underlying system.</value>
        [DataMember(Name="availableProcessors", EmitDefaultValue=false)]
        public int? AvailableProcessors { get; set; }

        /// <summary>
        /// The processor load average if supported by the underlying system.
        /// </summary>
        /// <value>The processor load average if supported by the underlying system.</value>
        [DataMember(Name="processorLoadAverage", EmitDefaultValue=false)]
        public double? ProcessorLoadAverage { get; set; }

        /// <summary>
        /// Total number of threads.
        /// </summary>
        /// <value>Total number of threads.</value>
        [DataMember(Name="totalThreads", EmitDefaultValue=false)]
        public int? TotalThreads { get; set; }

        /// <summary>
        /// Number of daemon threads.
        /// </summary>
        /// <value>Number of daemon threads.</value>
        [DataMember(Name="daemonThreads", EmitDefaultValue=false)]
        public int? DaemonThreads { get; set; }

        /// <summary>
        /// The uptime of the Java virtual machine
        /// </summary>
        /// <value>The uptime of the Java virtual machine</value>
        [DataMember(Name="uptime", EmitDefaultValue=false)]
        public string Uptime { get; set; }

        /// <summary>
        /// The flowfile repository storage usage.
        /// </summary>
        /// <value>The flowfile repository storage usage.</value>
        [DataMember(Name="flowFileRepositoryStorageUsage", EmitDefaultValue=false)]
        public StorageUsageDTO FlowFileRepositoryStorageUsage { get; set; }

        /// <summary>
        /// The content repository storage usage.
        /// </summary>
        /// <value>The content repository storage usage.</value>
        [DataMember(Name="contentRepositoryStorageUsage", EmitDefaultValue=false)]
        public List<StorageUsageDTO> ContentRepositoryStorageUsage { get; set; }

        /// <summary>
        /// The provenance repository storage usage.
        /// </summary>
        /// <value>The provenance repository storage usage.</value>
        [DataMember(Name="provenanceRepositoryStorageUsage", EmitDefaultValue=false)]
        public List<StorageUsageDTO> ProvenanceRepositoryStorageUsage { get; set; }

        /// <summary>
        /// The garbage collection details.
        /// </summary>
        /// <value>The garbage collection details.</value>
        [DataMember(Name="garbageCollection", EmitDefaultValue=false)]
        public List<GarbageCollectionDTO> GarbageCollection { get; set; }

        /// <summary>
        /// When the diagnostics were generated.
        /// </summary>
        /// <value>When the diagnostics were generated.</value>
        [DataMember(Name="statsLastRefreshed", EmitDefaultValue=false)]
        public string StatsLastRefreshed { get; set; }

        /// <summary>
        /// The nifi, os, java, and build version information
        /// </summary>
        /// <value>The nifi, os, java, and build version information</value>
        [DataMember(Name="versionInfo", EmitDefaultValue=false)]
        public VersionInfoDTO VersionInfo { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class SystemDiagnosticsSnapshotDTO {\n");
            sb.Append("  TotalNonHeap: ").Append(this.TotalNonHeap).Append("\n");
            sb.Append("  TotalNonHeapBytes: ").Append(this.TotalNonHeapBytes).Append("\n");
            sb.Append("  UsedNonHeap: ").Append(this.UsedNonHeap).Append("\n");
            sb.Append("  UsedNonHeapBytes: ").Append(this.UsedNonHeapBytes).Append("\n");
            sb.Append("  FreeNonHeap: ").Append(this.FreeNonHeap).Append("\n");
            sb.Append("  FreeNonHeapBytes: ").Append(this.FreeNonHeapBytes).Append("\n");
            sb.Append("  MaxNonHeap: ").Append(this.MaxNonHeap).Append("\n");
            sb.Append("  MaxNonHeapBytes: ").Append(this.MaxNonHeapBytes).Append("\n");
            sb.Append("  NonHeapUtilization: ").Append(this.NonHeapUtilization).Append("\n");
            sb.Append("  TotalHeap: ").Append(this.TotalHeap).Append("\n");
            sb.Append("  TotalHeapBytes: ").Append(this.TotalHeapBytes).Append("\n");
            sb.Append("  UsedHeap: ").Append(this.UsedHeap).Append("\n");
            sb.Append("  UsedHeapBytes: ").Append(this.UsedHeapBytes).Append("\n");
            sb.Append("  FreeHeap: ").Append(this.FreeHeap).Append("\n");
            sb.Append("  FreeHeapBytes: ").Append(this.FreeHeapBytes).Append("\n");
            sb.Append("  MaxHeap: ").Append(this.MaxHeap).Append("\n");
            sb.Append("  MaxHeapBytes: ").Append(this.MaxHeapBytes).Append("\n");
            sb.Append("  HeapUtilization: ").Append(this.HeapUtilization).Append("\n");
            sb.Append("  AvailableProcessors: ").Append(this.AvailableProcessors).Append("\n");
            sb.Append("  ProcessorLoadAverage: ").Append(this.ProcessorLoadAverage).Append("\n");
            sb.Append("  TotalThreads: ").Append(this.TotalThreads).Append("\n");
            sb.Append("  DaemonThreads: ").Append(this.DaemonThreads).Append("\n");
            sb.Append("  Uptime: ").Append(this.Uptime).Append("\n");
            sb.Append("  FlowFileRepositoryStorageUsage: ").Append(this.FlowFileRepositoryStorageUsage).Append("\n");
            sb.Append("  ContentRepositoryStorageUsage: ").Append(this.ContentRepositoryStorageUsage).Append("\n");
            sb.Append("  ProvenanceRepositoryStorageUsage: ").Append(this.ProvenanceRepositoryStorageUsage).Append("\n");
            sb.Append("  GarbageCollection: ").Append(this.GarbageCollection).Append("\n");
            sb.Append("  StatsLastRefreshed: ").Append(this.StatsLastRefreshed).Append("\n");
            sb.Append("  VersionInfo: ").Append(this.VersionInfo).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as SystemDiagnosticsSnapshotDTO);
        }

        /// <summary>
        /// Returns true if SystemDiagnosticsSnapshotDTO instances are equal
        /// </summary>
        /// <param name="input">Instance of SystemDiagnosticsSnapshotDTO to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(SystemDiagnosticsSnapshotDTO input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.TotalNonHeap == input.TotalNonHeap ||
                    (this.TotalNonHeap != null &&
                    this.TotalNonHeap.Equals(input.TotalNonHeap))
                ) && 
                (
                    this.TotalNonHeapBytes == input.TotalNonHeapBytes ||
                    (this.TotalNonHeapBytes != null &&
                    this.TotalNonHeapBytes.Equals(input.TotalNonHeapBytes))
                ) && 
                (
                    this.UsedNonHeap == input.UsedNonHeap ||
                    (this.UsedNonHeap != null &&
                    this.UsedNonHeap.Equals(input.UsedNonHeap))
                ) && 
                (
                    this.UsedNonHeapBytes == input.UsedNonHeapBytes ||
                    (this.UsedNonHeapBytes != null &&
                    this.UsedNonHeapBytes.Equals(input.UsedNonHeapBytes))
                ) && 
                (
                    this.FreeNonHeap == input.FreeNonHeap ||
                    (this.FreeNonHeap != null &&
                    this.FreeNonHeap.Equals(input.FreeNonHeap))
                ) && 
                (
                    this.FreeNonHeapBytes == input.FreeNonHeapBytes ||
                    (this.FreeNonHeapBytes != null &&
                    this.FreeNonHeapBytes.Equals(input.FreeNonHeapBytes))
                ) && 
                (
                    this.MaxNonHeap == input.MaxNonHeap ||
                    (this.MaxNonHeap != null &&
                    this.MaxNonHeap.Equals(input.MaxNonHeap))
                ) && 
                (
                    this.MaxNonHeapBytes == input.MaxNonHeapBytes ||
                    (this.MaxNonHeapBytes != null &&
                    this.MaxNonHeapBytes.Equals(input.MaxNonHeapBytes))
                ) && 
                (
                    this.NonHeapUtilization == input.NonHeapUtilization ||
                    (this.NonHeapUtilization != null &&
                    this.NonHeapUtilization.Equals(input.NonHeapUtilization))
                ) && 
                (
                    this.TotalHeap == input.TotalHeap ||
                    (this.TotalHeap != null &&
                    this.TotalHeap.Equals(input.TotalHeap))
                ) && 
                (
                    this.TotalHeapBytes == input.TotalHeapBytes ||
                    (this.TotalHeapBytes != null &&
                    this.TotalHeapBytes.Equals(input.TotalHeapBytes))
                ) && 
                (
                    this.UsedHeap == input.UsedHeap ||
                    (this.UsedHeap != null &&
                    this.UsedHeap.Equals(input.UsedHeap))
                ) && 
                (
                    this.UsedHeapBytes == input.UsedHeapBytes ||
                    (this.UsedHeapBytes != null &&
                    this.UsedHeapBytes.Equals(input.UsedHeapBytes))
                ) && 
                (
                    this.FreeHeap == input.FreeHeap ||
                    (this.FreeHeap != null &&
                    this.FreeHeap.Equals(input.FreeHeap))
                ) && 
                (
                    this.FreeHeapBytes == input.FreeHeapBytes ||
                    (this.FreeHeapBytes != null &&
                    this.FreeHeapBytes.Equals(input.FreeHeapBytes))
                ) && 
                (
                    this.MaxHeap == input.MaxHeap ||
                    (this.MaxHeap != null &&
                    this.MaxHeap.Equals(input.MaxHeap))
                ) && 
                (
                    this.MaxHeapBytes == input.MaxHeapBytes ||
                    (this.MaxHeapBytes != null &&
                    this.MaxHeapBytes.Equals(input.MaxHeapBytes))
                ) && 
                (
                    this.HeapUtilization == input.HeapUtilization ||
                    (this.HeapUtilization != null &&
                    this.HeapUtilization.Equals(input.HeapUtilization))
                ) && 
                (
                    this.AvailableProcessors == input.AvailableProcessors ||
                    (this.AvailableProcessors != null &&
                    this.AvailableProcessors.Equals(input.AvailableProcessors))
                ) && 
                (
                    this.ProcessorLoadAverage == input.ProcessorLoadAverage ||
                    (this.ProcessorLoadAverage != null &&
                    this.ProcessorLoadAverage.Equals(input.ProcessorLoadAverage))
                ) && 
                (
                    this.TotalThreads == input.TotalThreads ||
                    (this.TotalThreads != null &&
                    this.TotalThreads.Equals(input.TotalThreads))
                ) && 
                (
                    this.DaemonThreads == input.DaemonThreads ||
                    (this.DaemonThreads != null &&
                    this.DaemonThreads.Equals(input.DaemonThreads))
                ) && 
                (
                    this.Uptime == input.Uptime ||
                    (this.Uptime != null &&
                    this.Uptime.Equals(input.Uptime))
                ) && 
                (
                    this.FlowFileRepositoryStorageUsage == input.FlowFileRepositoryStorageUsage ||
                    (this.FlowFileRepositoryStorageUsage != null &&
                    this.FlowFileRepositoryStorageUsage.Equals(input.FlowFileRepositoryStorageUsage))
                ) && 
                (
                    this.ContentRepositoryStorageUsage == input.ContentRepositoryStorageUsage ||
                    this.ContentRepositoryStorageUsage != null &&
                    this.ContentRepositoryStorageUsage.SequenceEqual(input.ContentRepositoryStorageUsage)
                ) && 
                (
                    this.ProvenanceRepositoryStorageUsage == input.ProvenanceRepositoryStorageUsage ||
                    this.ProvenanceRepositoryStorageUsage != null &&
                    this.ProvenanceRepositoryStorageUsage.SequenceEqual(input.ProvenanceRepositoryStorageUsage)
                ) && 
                (
                    this.GarbageCollection == input.GarbageCollection ||
                    this.GarbageCollection != null &&
                    this.GarbageCollection.SequenceEqual(input.GarbageCollection)
                ) && 
                (
                    this.StatsLastRefreshed == input.StatsLastRefreshed ||
                    (this.StatsLastRefreshed != null &&
                    this.StatsLastRefreshed.Equals(input.StatsLastRefreshed))
                ) && 
                (
                    this.VersionInfo == input.VersionInfo ||
                    (this.VersionInfo != null &&
                    this.VersionInfo.Equals(input.VersionInfo))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.TotalNonHeap != null)
                    hashCode = hashCode * 59 + this.TotalNonHeap.GetHashCode();
                if (this.TotalNonHeapBytes != null)
                    hashCode = hashCode * 59 + this.TotalNonHeapBytes.GetHashCode();
                if (this.UsedNonHeap != null)
                    hashCode = hashCode * 59 + this.UsedNonHeap.GetHashCode();
                if (this.UsedNonHeapBytes != null)
                    hashCode = hashCode * 59 + this.UsedNonHeapBytes.GetHashCode();
                if (this.FreeNonHeap != null)
                    hashCode = hashCode * 59 + this.FreeNonHeap.GetHashCode();
                if (this.FreeNonHeapBytes != null)
                    hashCode = hashCode * 59 + this.FreeNonHeapBytes.GetHashCode();
                if (this.MaxNonHeap != null)
                    hashCode = hashCode * 59 + this.MaxNonHeap.GetHashCode();
                if (this.MaxNonHeapBytes != null)
                    hashCode = hashCode * 59 + this.MaxNonHeapBytes.GetHashCode();
                if (this.NonHeapUtilization != null)
                    hashCode = hashCode * 59 + this.NonHeapUtilization.GetHashCode();
                if (this.TotalHeap != null)
                    hashCode = hashCode * 59 + this.TotalHeap.GetHashCode();
                if (this.TotalHeapBytes != null)
                    hashCode = hashCode * 59 + this.TotalHeapBytes.GetHashCode();
                if (this.UsedHeap != null)
                    hashCode = hashCode * 59 + this.UsedHeap.GetHashCode();
                if (this.UsedHeapBytes != null)
                    hashCode = hashCode * 59 + this.UsedHeapBytes.GetHashCode();
                if (this.FreeHeap != null)
                    hashCode = hashCode * 59 + this.FreeHeap.GetHashCode();
                if (this.FreeHeapBytes != null)
                    hashCode = hashCode * 59 + this.FreeHeapBytes.GetHashCode();
                if (this.MaxHeap != null)
                    hashCode = hashCode * 59 + this.MaxHeap.GetHashCode();
                if (this.MaxHeapBytes != null)
                    hashCode = hashCode * 59 + this.MaxHeapBytes.GetHashCode();
                if (this.HeapUtilization != null)
                    hashCode = hashCode * 59 + this.HeapUtilization.GetHashCode();
                if (this.AvailableProcessors != null)
                    hashCode = hashCode * 59 + this.AvailableProcessors.GetHashCode();
                if (this.ProcessorLoadAverage != null)
                    hashCode = hashCode * 59 + this.ProcessorLoadAverage.GetHashCode();
                if (this.TotalThreads != null)
                    hashCode = hashCode * 59 + this.TotalThreads.GetHashCode();
                if (this.DaemonThreads != null)
                    hashCode = hashCode * 59 + this.DaemonThreads.GetHashCode();
                if (this.Uptime != null)
                    hashCode = hashCode * 59 + this.Uptime.GetHashCode();
                if (this.FlowFileRepositoryStorageUsage != null)
                    hashCode = hashCode * 59 + this.FlowFileRepositoryStorageUsage.GetHashCode();
                if (this.ContentRepositoryStorageUsage != null)
                    hashCode = hashCode * 59 + this.ContentRepositoryStorageUsage.GetHashCode();
                if (this.ProvenanceRepositoryStorageUsage != null)
                    hashCode = hashCode * 59 + this.ProvenanceRepositoryStorageUsage.GetHashCode();
                if (this.GarbageCollection != null)
                    hashCode = hashCode * 59 + this.GarbageCollection.GetHashCode();
                if (this.StatsLastRefreshed != null)
                    hashCode = hashCode * 59 + this.StatsLastRefreshed.GetHashCode();
                if (this.VersionInfo != null)
                    hashCode = hashCode * 59 + this.VersionInfo.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}

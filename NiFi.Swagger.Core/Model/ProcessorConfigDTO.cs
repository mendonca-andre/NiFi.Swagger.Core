/* 
 * NiFi Rest Api
 *
 * The Rest Api provides programmatic access to command and control a NiFi instance in real time. Start and                                              stop processors, monitor queues, query provenance data, and more. Each endpoint below includes a description,                                             definitions of the expected input and output, potential response codes, and the authorizations required                                             to invoke each service.
 *
 * OpenAPI spec version: 1.9.1
 * Contact: dev@nifi.apache.org
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

namespace NiFi.Swagger.Core.Model
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations;
    using System.Linq;
    using System.Runtime.Serialization;
    using System.Text;

    using Newtonsoft.Json;

    /// <summary>
    /// ProcessorConfigDTO
    /// </summary>
    [DataContract]
    public partial class ProcessorConfigDTO :  IEquatable<ProcessorConfigDTO>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ProcessorConfigDTO" /> class.
        /// </summary>
        /// <param name="properties">The properties for the processor. Properties whose value is not set will only contain the property name..</param>
        /// <param name="descriptors">Descriptors for the processor&#39;s properties..</param>
        /// <param name="schedulingPeriod">The frequency with which to schedule the processor. The format of the value will depend on th value of schedulingStrategy..</param>
        /// <param name="schedulingStrategy">Indcates whether the prcessor should be scheduled to run in event or timer driven mode..</param>
        /// <param name="executionNode">Indicates the node where the process will execute..</param>
        /// <param name="penaltyDuration">The amount of time that is used when the process penalizes a flowfile..</param>
        /// <param name="yieldDuration">The amount of time that must elapse before this processor is scheduled again after yielding..</param>
        /// <param name="bulletinLevel">The level at which the processor will report bulletins..</param>
        /// <param name="runDurationMillis">The run duration for the processor in milliseconds..</param>
        /// <param name="concurrentlySchedulableTaskCount">The number of tasks that should be concurrently schedule for the processor. If the processor doesn&#39;t allow parallol processing then any positive input will be ignored..</param>
        /// <param name="autoTerminatedRelationships">The names of all relationships that cause a flow file to be terminated if the relationship is not connected elsewhere. This property differs from the &#39;isAutoTerminate&#39; property of the RelationshipDTO in that the RelationshipDTO is meant to depict the current configuration, whereas this property can be set in a DTO when updating a Processor in order to change which Relationships should be auto-terminated..</param>
        /// <param name="comments">The comments for the processor..</param>
        /// <param name="customUiUrl">The URL for the processor&#39;s custom configuration UI if applicable..</param>
        /// <param name="lossTolerant">Whether the processor is loss tolerant..</param>
        /// <param name="annotationData">The annotation data for the processor used to relay configuration between a custom UI and the procesosr..</param>
        /// <param name="defaultConcurrentTasks">Maps default values for concurrent tasks for each applicable scheduling strategy..</param>
        /// <param name="defaultSchedulingPeriod">Maps default values for scheduling period for each applicable scheduling strategy..</param>
        public ProcessorConfigDTO(Dictionary<string, string> properties = default(Dictionary<string, string>), Dictionary<string, PropertyDescriptorDTO> descriptors = default(Dictionary<string, PropertyDescriptorDTO>), string schedulingPeriod = default(string), string schedulingStrategy = default(string), string executionNode = default(string), string penaltyDuration = default(string), string yieldDuration = default(string), string bulletinLevel = default(string), long? runDurationMillis = default(long?), int? concurrentlySchedulableTaskCount = default(int?), List<string> autoTerminatedRelationships = default(List<string>), string comments = default(string), string customUiUrl = default(string), bool? lossTolerant = default(bool?), string annotationData = default(string), Dictionary<string, string> defaultConcurrentTasks = default(Dictionary<string, string>), Dictionary<string, string> defaultSchedulingPeriod = default(Dictionary<string, string>))
        {
            this.Properties = properties;
            this.Descriptors = descriptors;
            this.SchedulingPeriod = schedulingPeriod;
            this.SchedulingStrategy = schedulingStrategy;
            this.ExecutionNode = executionNode;
            this.PenaltyDuration = penaltyDuration;
            this.YieldDuration = yieldDuration;
            this.BulletinLevel = bulletinLevel;
            this.RunDurationMillis = runDurationMillis;
            this.ConcurrentlySchedulableTaskCount = concurrentlySchedulableTaskCount;
            this.AutoTerminatedRelationships = autoTerminatedRelationships;
            this.Comments = comments;
            this.CustomUiUrl = customUiUrl;
            this.LossTolerant = lossTolerant;
            this.AnnotationData = annotationData;
            this.DefaultConcurrentTasks = defaultConcurrentTasks;
            this.DefaultSchedulingPeriod = defaultSchedulingPeriod;
        }
        
        /// <summary>
        /// The properties for the processor. Properties whose value is not set will only contain the property name.
        /// </summary>
        /// <value>The properties for the processor. Properties whose value is not set will only contain the property name.</value>
        [DataMember(Name="properties", EmitDefaultValue=false)]
        public Dictionary<string, string> Properties { get; set; }

        /// <summary>
        /// Descriptors for the processor&#39;s properties.
        /// </summary>
        /// <value>Descriptors for the processor&#39;s properties.</value>
        [DataMember(Name="descriptors", EmitDefaultValue=false)]
        public Dictionary<string, PropertyDescriptorDTO> Descriptors { get; set; }

        /// <summary>
        /// The frequency with which to schedule the processor. The format of the value will depend on th value of schedulingStrategy.
        /// </summary>
        /// <value>The frequency with which to schedule the processor. The format of the value will depend on th value of schedulingStrategy.</value>
        [DataMember(Name="schedulingPeriod", EmitDefaultValue=false)]
        public string SchedulingPeriod { get; set; }

        /// <summary>
        /// Indcates whether the prcessor should be scheduled to run in event or timer driven mode.
        /// </summary>
        /// <value>Indcates whether the prcessor should be scheduled to run in event or timer driven mode.</value>
        [DataMember(Name="schedulingStrategy", EmitDefaultValue=false)]
        public string SchedulingStrategy { get; set; }

        /// <summary>
        /// Indicates the node where the process will execute.
        /// </summary>
        /// <value>Indicates the node where the process will execute.</value>
        [DataMember(Name="executionNode", EmitDefaultValue=false)]
        public string ExecutionNode { get; set; }

        /// <summary>
        /// The amount of time that is used when the process penalizes a flowfile.
        /// </summary>
        /// <value>The amount of time that is used when the process penalizes a flowfile.</value>
        [DataMember(Name="penaltyDuration", EmitDefaultValue=false)]
        public string PenaltyDuration { get; set; }

        /// <summary>
        /// The amount of time that must elapse before this processor is scheduled again after yielding.
        /// </summary>
        /// <value>The amount of time that must elapse before this processor is scheduled again after yielding.</value>
        [DataMember(Name="yieldDuration", EmitDefaultValue=false)]
        public string YieldDuration { get; set; }

        /// <summary>
        /// The level at which the processor will report bulletins.
        /// </summary>
        /// <value>The level at which the processor will report bulletins.</value>
        [DataMember(Name="bulletinLevel", EmitDefaultValue=false)]
        public string BulletinLevel { get; set; }

        /// <summary>
        /// The run duration for the processor in milliseconds.
        /// </summary>
        /// <value>The run duration for the processor in milliseconds.</value>
        [DataMember(Name="runDurationMillis", EmitDefaultValue=false)]
        public long? RunDurationMillis { get; set; }

        /// <summary>
        /// The number of tasks that should be concurrently schedule for the processor. If the processor doesn&#39;t allow parallol processing then any positive input will be ignored.
        /// </summary>
        /// <value>The number of tasks that should be concurrently schedule for the processor. If the processor doesn&#39;t allow parallol processing then any positive input will be ignored.</value>
        [DataMember(Name="concurrentlySchedulableTaskCount", EmitDefaultValue=false)]
        public int? ConcurrentlySchedulableTaskCount { get; set; }

        /// <summary>
        /// The names of all relationships that cause a flow file to be terminated if the relationship is not connected elsewhere. This property differs from the &#39;isAutoTerminate&#39; property of the RelationshipDTO in that the RelationshipDTO is meant to depict the current configuration, whereas this property can be set in a DTO when updating a Processor in order to change which Relationships should be auto-terminated.
        /// </summary>
        /// <value>The names of all relationships that cause a flow file to be terminated if the relationship is not connected elsewhere. This property differs from the &#39;isAutoTerminate&#39; property of the RelationshipDTO in that the RelationshipDTO is meant to depict the current configuration, whereas this property can be set in a DTO when updating a Processor in order to change which Relationships should be auto-terminated.</value>
        [DataMember(Name="autoTerminatedRelationships", EmitDefaultValue=false)]
        public List<string> AutoTerminatedRelationships { get; set; }

        /// <summary>
        /// The comments for the processor.
        /// </summary>
        /// <value>The comments for the processor.</value>
        [DataMember(Name="comments", EmitDefaultValue=false)]
        public string Comments { get; set; }

        /// <summary>
        /// The URL for the processor&#39;s custom configuration UI if applicable.
        /// </summary>
        /// <value>The URL for the processor&#39;s custom configuration UI if applicable.</value>
        [DataMember(Name="customUiUrl", EmitDefaultValue=false)]
        public string CustomUiUrl { get; set; }

        /// <summary>
        /// Whether the processor is loss tolerant.
        /// </summary>
        /// <value>Whether the processor is loss tolerant.</value>
        [DataMember(Name="lossTolerant", EmitDefaultValue=false)]
        public bool? LossTolerant { get; set; }

        /// <summary>
        /// The annotation data for the processor used to relay configuration between a custom UI and the procesosr.
        /// </summary>
        /// <value>The annotation data for the processor used to relay configuration between a custom UI and the procesosr.</value>
        [DataMember(Name="annotationData", EmitDefaultValue=false)]
        public string AnnotationData { get; set; }

        /// <summary>
        /// Maps default values for concurrent tasks for each applicable scheduling strategy.
        /// </summary>
        /// <value>Maps default values for concurrent tasks for each applicable scheduling strategy.</value>
        [DataMember(Name="defaultConcurrentTasks", EmitDefaultValue=false)]
        public Dictionary<string, string> DefaultConcurrentTasks { get; set; }

        /// <summary>
        /// Maps default values for scheduling period for each applicable scheduling strategy.
        /// </summary>
        /// <value>Maps default values for scheduling period for each applicable scheduling strategy.</value>
        [DataMember(Name="defaultSchedulingPeriod", EmitDefaultValue=false)]
        public Dictionary<string, string> DefaultSchedulingPeriod { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class ProcessorConfigDTO {\n");
            sb.Append("  Properties: ").Append(this.Properties).Append("\n");
            sb.Append("  Descriptors: ").Append(this.Descriptors).Append("\n");
            sb.Append("  SchedulingPeriod: ").Append(this.SchedulingPeriod).Append("\n");
            sb.Append("  SchedulingStrategy: ").Append(this.SchedulingStrategy).Append("\n");
            sb.Append("  ExecutionNode: ").Append(this.ExecutionNode).Append("\n");
            sb.Append("  PenaltyDuration: ").Append(this.PenaltyDuration).Append("\n");
            sb.Append("  YieldDuration: ").Append(this.YieldDuration).Append("\n");
            sb.Append("  BulletinLevel: ").Append(this.BulletinLevel).Append("\n");
            sb.Append("  RunDurationMillis: ").Append(this.RunDurationMillis).Append("\n");
            sb.Append("  ConcurrentlySchedulableTaskCount: ").Append(this.ConcurrentlySchedulableTaskCount).Append("\n");
            sb.Append("  AutoTerminatedRelationships: ").Append(this.AutoTerminatedRelationships).Append("\n");
            sb.Append("  Comments: ").Append(this.Comments).Append("\n");
            sb.Append("  CustomUiUrl: ").Append(this.CustomUiUrl).Append("\n");
            sb.Append("  LossTolerant: ").Append(this.LossTolerant).Append("\n");
            sb.Append("  AnnotationData: ").Append(this.AnnotationData).Append("\n");
            sb.Append("  DefaultConcurrentTasks: ").Append(this.DefaultConcurrentTasks).Append("\n");
            sb.Append("  DefaultSchedulingPeriod: ").Append(this.DefaultSchedulingPeriod).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ProcessorConfigDTO);
        }

        /// <summary>
        /// Returns true if ProcessorConfigDTO instances are equal
        /// </summary>
        /// <param name="input">Instance of ProcessorConfigDTO to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ProcessorConfigDTO input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Properties == input.Properties ||
                    this.Properties != null &&
                    this.Properties.SequenceEqual(input.Properties)
                ) && 
                (
                    this.Descriptors == input.Descriptors ||
                    this.Descriptors != null &&
                    this.Descriptors.SequenceEqual(input.Descriptors)
                ) && 
                (
                    this.SchedulingPeriod == input.SchedulingPeriod ||
                    (this.SchedulingPeriod != null &&
                    this.SchedulingPeriod.Equals(input.SchedulingPeriod))
                ) && 
                (
                    this.SchedulingStrategy == input.SchedulingStrategy ||
                    (this.SchedulingStrategy != null &&
                    this.SchedulingStrategy.Equals(input.SchedulingStrategy))
                ) && 
                (
                    this.ExecutionNode == input.ExecutionNode ||
                    (this.ExecutionNode != null &&
                    this.ExecutionNode.Equals(input.ExecutionNode))
                ) && 
                (
                    this.PenaltyDuration == input.PenaltyDuration ||
                    (this.PenaltyDuration != null &&
                    this.PenaltyDuration.Equals(input.PenaltyDuration))
                ) && 
                (
                    this.YieldDuration == input.YieldDuration ||
                    (this.YieldDuration != null &&
                    this.YieldDuration.Equals(input.YieldDuration))
                ) && 
                (
                    this.BulletinLevel == input.BulletinLevel ||
                    (this.BulletinLevel != null &&
                    this.BulletinLevel.Equals(input.BulletinLevel))
                ) && 
                (
                    this.RunDurationMillis == input.RunDurationMillis ||
                    (this.RunDurationMillis != null &&
                    this.RunDurationMillis.Equals(input.RunDurationMillis))
                ) && 
                (
                    this.ConcurrentlySchedulableTaskCount == input.ConcurrentlySchedulableTaskCount ||
                    (this.ConcurrentlySchedulableTaskCount != null &&
                    this.ConcurrentlySchedulableTaskCount.Equals(input.ConcurrentlySchedulableTaskCount))
                ) && 
                (
                    this.AutoTerminatedRelationships == input.AutoTerminatedRelationships ||
                    this.AutoTerminatedRelationships != null &&
                    this.AutoTerminatedRelationships.SequenceEqual(input.AutoTerminatedRelationships)
                ) && 
                (
                    this.Comments == input.Comments ||
                    (this.Comments != null &&
                    this.Comments.Equals(input.Comments))
                ) && 
                (
                    this.CustomUiUrl == input.CustomUiUrl ||
                    (this.CustomUiUrl != null &&
                    this.CustomUiUrl.Equals(input.CustomUiUrl))
                ) && 
                (
                    this.LossTolerant == input.LossTolerant ||
                    (this.LossTolerant != null &&
                    this.LossTolerant.Equals(input.LossTolerant))
                ) && 
                (
                    this.AnnotationData == input.AnnotationData ||
                    (this.AnnotationData != null &&
                    this.AnnotationData.Equals(input.AnnotationData))
                ) && 
                (
                    this.DefaultConcurrentTasks == input.DefaultConcurrentTasks ||
                    this.DefaultConcurrentTasks != null &&
                    this.DefaultConcurrentTasks.SequenceEqual(input.DefaultConcurrentTasks)
                ) && 
                (
                    this.DefaultSchedulingPeriod == input.DefaultSchedulingPeriod ||
                    this.DefaultSchedulingPeriod != null &&
                    this.DefaultSchedulingPeriod.SequenceEqual(input.DefaultSchedulingPeriod)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Properties != null)
                    hashCode = hashCode * 59 + this.Properties.GetHashCode();
                if (this.Descriptors != null)
                    hashCode = hashCode * 59 + this.Descriptors.GetHashCode();
                if (this.SchedulingPeriod != null)
                    hashCode = hashCode * 59 + this.SchedulingPeriod.GetHashCode();
                if (this.SchedulingStrategy != null)
                    hashCode = hashCode * 59 + this.SchedulingStrategy.GetHashCode();
                if (this.ExecutionNode != null)
                    hashCode = hashCode * 59 + this.ExecutionNode.GetHashCode();
                if (this.PenaltyDuration != null)
                    hashCode = hashCode * 59 + this.PenaltyDuration.GetHashCode();
                if (this.YieldDuration != null)
                    hashCode = hashCode * 59 + this.YieldDuration.GetHashCode();
                if (this.BulletinLevel != null)
                    hashCode = hashCode * 59 + this.BulletinLevel.GetHashCode();
                if (this.RunDurationMillis != null)
                    hashCode = hashCode * 59 + this.RunDurationMillis.GetHashCode();
                if (this.ConcurrentlySchedulableTaskCount != null)
                    hashCode = hashCode * 59 + this.ConcurrentlySchedulableTaskCount.GetHashCode();
                if (this.AutoTerminatedRelationships != null)
                    hashCode = hashCode * 59 + this.AutoTerminatedRelationships.GetHashCode();
                if (this.Comments != null)
                    hashCode = hashCode * 59 + this.Comments.GetHashCode();
                if (this.CustomUiUrl != null)
                    hashCode = hashCode * 59 + this.CustomUiUrl.GetHashCode();
                if (this.LossTolerant != null)
                    hashCode = hashCode * 59 + this.LossTolerant.GetHashCode();
                if (this.AnnotationData != null)
                    hashCode = hashCode * 59 + this.AnnotationData.GetHashCode();
                if (this.DefaultConcurrentTasks != null)
                    hashCode = hashCode * 59 + this.DefaultConcurrentTasks.GetHashCode();
                if (this.DefaultSchedulingPeriod != null)
                    hashCode = hashCode * 59 + this.DefaultSchedulingPeriod.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
